Стандартному объекту lock не важно, какой поток в данный момент держит замок. Если замок в данный момент удерживается, любой поток, который попытается получить к нему доступ будет заблокирован, даже если тот же поток в данный момент удерживает блок. Давайте взглянем на следующий пример:

import threading
 
lock = threading.Lock()
 
def get_first_part():
    lock.acquire()
    try:
        # берем данные для первой части из общих ресурсах.
    finally:
        lock.release()
    return data
 
def get_second_part():
    lock.acquire()
    try:
        # берем данные для второй части из общих ресурсах.
    finally:
        lock.release()
    return data

Здесь мы имеем наш общий ресурс и две функции доступа, задача которых извлекать разные части ресурса. Функции доступа также используют замки для того, чтобы сторонний поток не менял ресурс, пока мы получаем к нему доступ. Теперь, если нам нужно добавить третью функцию, которая извлекает обе части, мы столкнемся с проблемой. Наивность данного подхода заключается в том, что мы просто вызываем две функции, и получаем суммарный результат:

def get_both_parts():
    first = get_first_part()
    second = get_second_part()
    return first, second

Проблема заключается в том, что сторонний поток меняет ресурс между двумя вызовами, что приводит к противоречивым результатам. Очевидное решение данной проблемы – добавить замок в данной функции:

def get_both_parts():
    lock.acquire()
    try:
        first = get_first_part()
        second = get_second_part()
    finally:
        lock.release()
    return first, second

В любом случае, это не сработает. Индивидуальные функции доступа застрянут, так как другая функция в данный момент держит блок. Чтобы обойти это, вы можете добавить флаги к функциям доступа, которые позволят внешней функции отключить блок, но это чревато ошибками и может быстро выйти из-под контроля. К счастью, модуль threading содержит более практичный инструмент реализации блокировки – реентерабельные замки (RLock).