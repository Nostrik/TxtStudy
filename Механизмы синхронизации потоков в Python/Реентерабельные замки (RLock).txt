Класс RLock – это версия замка, который выполняет функцию блокировки только в том случае, если замок удерживает другой поток. В то время как обычные замки блокируют тогда, когда тот же поток пытается получить к одному и тому же замку дважды, реентерабельный замок блокирует только в том случае, если другой поток уже держит замок. Если нынешний поток пытается получить доступ к замку, который и так удерживается, осуществление данной операции проходит в привычном порядке.

lock = threading.Lock()
lock.acquire()
lock.acquire() # заблокирует
 
lock = threading.RLock()
lock.acquire()
lock.acquire() # не будет блокировать

В основном это используется для вложенного доступа к общим ресурсам, как показано в предыдущем примере. Для того, чтобы наладить методы доступа в нашем примере, просто замените обычный Lock на RLock и вложенные вызовы заработают так, как надо.

import threading
 
lock = threading.RLock()
 
def get_first_part():
    lock.acquire()
    try:
        # берем данные для первой части из общих ресурсах.
    finally:
        lock.release()
    return data
 
def get_second_part():
    lock.acquire()
    try:
        # берем данные для второй части из общих ресурсах.
    finally:
        lock.release()
    return data

При этом вы можете выбрать отдельные части, или обе за раз, не застревая и не получая взаимоисключающих данных. Обратите внимание на то, что этот замок отслеживает уровень рекурсии, так что вам все раз нужно вызвать release по одному разу для каждого вызова для получения доступа.