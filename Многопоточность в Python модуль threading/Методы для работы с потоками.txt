Для создания и управления потоками используются различные методы класса Thread. С их помощью можно легко манипулировать сразу несколькими потоками и определять их поведение.

start()

Он используется для запуска созданного потока. После использования threading.Thread() создаётся новый поток, однако он неактивен. Для того чтобы он начал работу, используется метод start().

import threading 
def myfunc(a, b): 
    print('сумма :',a + b) 
thr1 = threading.Thread(target = myfunc, args = (1, 2))
thr1.start()

Здесь пока мы не вызвали метод start, функция myfunc не будет запущена.

join()

Этот метод блокирует выполнение потока, который его вызвал, до тех пор пока не завершится поток, метод которого был вызван. То есть если в потоке thread1 был вызван метод потока thread2: thread2.join(), то поток thread1 будет приостановлен до тех пор, пока выполнение thread2 не завершится.

С помощью этого метода можно заставить программу дождаться завершения демонического потока. Например, если вызвать метод в основном потоке, то программа не завершится, пока не выполнится демонический поток.

У метода join() есть аргумент timeout. По умолчанию он имеет значение None, но программист может передать в него число с плавающей точкой.
Если аргумент имеет значение по умолчанию, то выполнение потока приостанавливается, пока выполняется поток метода.

Если передать в качестве аргумента число, то для метода join() установится время ожидания, когда оно истечёт, поток продолжит свою работу.

Например, thr1.join(100) означает, что будет ожидаться завершение выполнения потока thr1 не более 100 секунд.

Так как метод join() всегда возвращает None, чтобы проверить, успел ли полностью выполниться поток за указанный timeout, нужно проверить, выполняется ли поток с помощью метода is_alive().

Рассмотрим пример:

import threading
import time
def myfunc(a, b):
    time.sleep(2.5)
    print('сумма :', a + b)
thr1 = threading.Thread(target = myfunc, args = (1, 2), daemon=True)
thr1.start()
thr1.join(0.125)
if thr1.is_alive():
    print('поток не успел завершиться')
else:
    print('вычисления завершены')

поток не успел завершиться

Здесь мы делаем поток демоническим, чтобы программа не дожидалась окончания выполнения функции. Подключаем модуль time, для того, чтобы сделать задержку в функции на 2.5 секунд. После старта потока, мы приостанавливаем основной поток на 0.125 секунд. Потом выполняем проверку is_alive(). Если выведет True, значит поток не закончил выполнение за 0.125 секунды.

run()

В этом методе описываются операции, выполняемые потоком. Он используется, когда явно создается экземпляр класса. Пример:

import threading as th
import time
class Thr1(th.Thread): # Создаём экземпляр потока Thread
    def __init__(self, var):
        th.Thread.__init__(self)
        self.daemon = True # Указываем, что этот поток - демон
        self.var = var # это интервал, передаваемый в качестве аргумента

    def run(self): # метод, который выполняется при запуске потока
        num = 1
        while True:
            y = num*num + num / (num - 10) # Вычисляем функцию
            num += 1
            print("При num =", num, " функция y =", y) # Печатаем результат
            time.sleep(self.var) # Ждём указанное количество секунд
x = Thr1(0.9)
x.start()
time.sleep(2)

При num = 2  функция y = 0.8888888888888888
При num = 3  функция y = 3.75
При num = 4  функция y = 8.571428571428571

is_alive()

Метод проверяет выполняется ли поток в данный момент. Его часто используют в связке с методом join(). Кроме того, с его помощью можно грамотно управлять выполнением потоков демонов, не позволяя им неожиданно завершить работу при закрытии программы, например:

while True:
    if thr1.is_alive() == True: # Проверяем, выполняется ли поток демон
        time.sleep(1) # Если да, ждем 1 секунду и проверяем снова
    else:
        break # Если нет, выходим из цикла и закрываем программу