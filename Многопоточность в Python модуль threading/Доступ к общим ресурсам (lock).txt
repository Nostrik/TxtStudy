Для того чтобы предотвратить состояние гонки, нужно использовать блокировку threading.Lock(), которая не позволяет сразу нескольким потокам работать с одними и теми же данными. Иными словами, Lock защищает данные от одновременного доступа.

threading.Lock() – возвращает объект, который, образно выражаясь, является дверью в комнату, которая запирается, если в комнате кто-то находится. То есть если поток использовал Lock (вошел в комнату), то другой поток вынужден ждать до тех пор, пока использовавший Lock поток не откажется от него (выйдет из комнаты).

У полученного объекта есть два метода: acquire() и release(). Рассмотрим их.
acquire()

Метод позволяет потоку получить блокировку. Имеет два аргумента: blocking и timeout.

Когда вызывается с аргументом blocking равным True (значение по умолчанию), блокирует Lock до тех пор, пока он не будет разблокирован и возвращает True. Если объект уже заблокирован, поток приостанавливается и ждёт, пока объект не будет разблокирован, а затем сам блокирует его.

При вызове с аргументов False, если объект Lock разблокирован, метод блокирует его и возвращает True. Если Lock уже заблокирован, метод ничего не делает и возвращает False.

Аргумент timeout (по умолчанию -1) можно изменить, только если аргумент blocking имеет значение True. Если в качестве аргумента передать положительное значение, то объект блокируется на указанное количество секунд с учётом времени ожидания блокировки. Аргумент по умолчанию указывает методу использовать бесконечное ожидание.
release()

Этот метод разблокирует объект Lock. Интерпретатор позволяет вызывать его из любого потока, а не только из потока, который заблокировал Lock в данный момент.

Метод ничего не возвращает и вызывает ошибку RuntimeError, если вызывается, когда объект Lock уже разблокирован.

Вот пример:

import threading
lock = threading.Lock()
x = 'Рython 2'
# ...
lock.acquire()
x = 'Рython 3'
print(x)
lock.release()

Python 3

Здесь мы создаём объект lock, с его помощью мы будем безопасно считывать и изменять данные. В качестве данных, которые мы будем блокировать в данном примере это одна переменная x. Далее показано безопасное изменение данных: вначале с помощью acquire дожидаемся своей очереди доступа к ним. Затем изменяем их (в нашем примере перезаписываем значение переменной с «Python 2» на «Python 3»). Далее выводим значение в консоль. После этого освобождаем доступ для других потоков. Если все потоки, которым нужен будет доступ к данным x будут использовать lock, то можно избежать «Состояния гонки».
deadlock

При использовании Lock возникает серьезная проблема, которая приводит к полной остановки работы программы. Если вызвать метод acquire(), а объект Lock уже заблокирован, то вызвавший acquire() поток будет ждать, пока заблокировавший объект поток не вызовет release().

Если один поток вызывает метод блокировки несколько раз подряд, то выполнение потока приостанавливается, пока он сам не вызовет release(). Однако он не может вызвать release, потому что его выполнение приостановлено, что означает бесконечную блокировку программы.

Самоблокировку можно предотвратить, если удалить лишний вызов acquire(), но это не всегда возможно. Самоблокировка может происходить из-за следующий вещей:

    Возникновение ошибок, когда Lock остаётся заблокированным.
    Неправильное проектирование программы, когда одна функция вызывается другой функцией, у которой отсутствует блокировка.

В случае возникновения ошибок достаточно воспользоваться конструкцией try-finally или оператором with.

Вот пример с with:

lock = threading.Lock() 
with lock:
    # операторы
    pass

Конструкция try-finally позволяет удалять блокировку даже в случае возникновения ошибок, что позволяет избежать deadblock. Пример:

lock = threading.Lock()
lock.acquire()
try:
    # операторы
    pass
finally:
    lock.release()

Конструкция try-finally гарантирует, что код в finally будет исполнен всегда, независимо от ошибок и результатов блока try.

Однако это не работает в случае самоблокировки из-за неправильного проектирования программы. Для этого был создан объект RLock.
RLock

Если Lock заблокирован, он блокирует любой поток, попытавшийся сделать то же самое, даже если этот поток и является владельцем блокировки в данный момент. Например, программист написал код:

import threading
lock1 = threading.Lock()
def part1():
    lock1.acquire()
    try:
        # вычислить сумму элементов первой части объекта
        pass
    finally:
        lock1.release()
    return sum
def part2():
    lock1.acquire()
    try:
        # вычислить сумму элементов второй части объекта
        pass
    finally:
        lock1.release()
    return sum
def both_parts():
    p1 = part1()
    p2 = part2()
    return p1, p2

Данный код будет работать, но его проблема заключается в том, что при вызове функции both_parts, в ней вызываются функции part1 и part2. Между вызовами этих функций может получить доступ к данным какой-нибудь другой поток и их поменять. А что делать, если нужно избежать изменения другим потоком?

Чтобы решить проблему, нужно заблокировать lock1 и в both_parts, перепишем её:

def both_parts():
    lock1.acquire()
    try:
        p1 = part1()
        p2 = part2()
    finally:
        lock1.release()
    return p1, p2

Идея проста: внешняя both_parts блокирует поток на время выполнения функций part1 и part1. Каждая из функций также блокирует поток для суммирования своей части объекта. Однако объект Lock не позволит этого сделать, этот код приведет к полному зависанию программы, потому что для Lock нет разницы, где в потоке был вызван acquire().

RLock блокирует поток только в том случае, если объект заблокирован другим потоком. Используя RLock, поток никогда не сможет заблокировать сам себя.

Использовать RLock нужно для управления вложенным доступом к разделяемым объектам. Чтобы решить возникшую проблему с Lock в коде выше, достаточно заменить строчку «lock1 = threading.Lock()» на «lock1 = threading.RLock()».
Также следует помнить, что, хотя и можно вызывать acquire() несколько раз, метод release() нужно вызвать столько же раз. При каждом вызове acquire() уровень рекурсии увеличивается на единицу, соответственно при каждом вызове release() он уменьшается на единицу.