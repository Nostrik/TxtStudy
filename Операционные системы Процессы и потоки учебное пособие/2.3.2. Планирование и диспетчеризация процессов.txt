Самую простую модель диспетчеризации, т.е. определения схе-
мы чередования процессов, можно построить, используя модель про-
цесса с двумя состояниями: выполняющийся или не выполняющийся.
На рис. 2.2 показана модель процесса с двумя состояниями.

Поведение диспетчера можно описать следующим образом.
Прерванный      процесс переходит в очередь процессов, ожидающих
выполнения. В случае завершения процесс выводится из системы.
Диспетчер выбирает из очереди следующий процесс для выполнения.
Если бы все процессы всегда были готовы к выполнению, то очередь
на рис 2.2 могла бы работать эффективно, т.е. обслуживать имею-
щиеся в наличии процессы карусельным (round robin) методом, когда
каждому процессу отводится определенный промежуток времени, по
истечении которого процесс возвращается обратно в очередь. Однако
модель с двумя состояниями не является адекватной. Некоторые из
невыполняющихся процессов готовы к выполнению, в то время как
другие являются заблокированными и ждут окончания операции вво-
да-вывода. Поэтому более адекватной реальности является модель
процесса с пятью состояниями:
          выполняющийся;
          готовый к выполнению;
          блокированный (процесс не может выполниться до наступ-
          ления некоторого события, например до завершения опе-
          рации ввода-вывода);
          новый (только что созданный процесс, который еще не по-
          мещен ОС в пул выполнимых процессов и не загружен в
          ОЗУ);
          завершающийся (процесс, удаленный ОС из пула выпол-
          нимых процессов).
На рис. 2.3 показаны типы событий, соответствующие каждому из
возможных переходов из одного состояния в другое. Возможны сле-
дующие переходы:
          Нулевое состояние/Новый. ОС выполняет все необходи-
          мые действия для создания нового процесса. Присваивает


процессу идентификатор, формирует управляющие табли-
цы процесса.
Новый/Готовый. ОС переводит процесс в состояние гото-
вого к выполнению по мере готовности к обработке допол-
нительных процессов. Существуют ограничения на коли-
чество запущенных процессов и на объем выделяемой для
процессов виртуальной памяти (для поддержки нормаль-
ной производительности системы).
Готовый/Выполняющийся. ОС выбирает один из готовых
для выполнения процессов в соответствии с принятой стра-
тегией планирования.
Выполняющийся/Завершающийся. ОС прекращает выпол-
нение процесса по одной из причин завершения процессов.
Выполняющийся/Готовый.       ОС прерывает выполнение
процесса или вытесняет процесс по истечении заданного
кванта времени или из-за наличия другого процесса с более
высоким приоритетом.
Выполняющийся/Блокированный. Процесс переводится в
заблокированное состояние, если для продолжения работы
требуется наступление некоторого события (ожидание за-
вершения операции ввода-вывода, сообщения от другого
процесса и т.п.).
Блокированный/Готовый. Заблокированный процесс пере-
ходит в состояние готовности к выполнению при наступле-
нии ожидаемого события.
Готовый/Завершающийся. Родительский процесс может
прервать выполнение дочернего процесса. Дочерний про-
цесс может прекратиться при завершении родительского
процесса.

Обобщением модели с пятью состояниями является модель с
семью состояниями, позволяющая более адекватно смоделировать
реализацию операционных систем. В данной модели вводится допол-
нительно понятие приостановленного процесса и два новых состоя-
ния:
          Блокированный/Приостановленный. Процесс, выгружен-
          ный на диск и ожидающий какого-то события.
          Готовый/Приостановленный. Процесс, находящийся на
          диске, но уже готовый к выполнению. Для этого его необ-
          ходимо только загрузить в основную память.
Приостановленный процесс является процессом, который отсутству-
ет в основной памяти и не может быть запущен немедленно. Причи-
нами приостановки процесса могут быть:
     • необходимость освободить основную память для оптимизации
       производительности виртуальной памяти;
     • периодический режим выполнения процесса (например, про-
       грамма анализа использования ресурсов компьютера);
     • приостановка дочерних процессов родительским для их провер-
       ки или координации;
     • приостановка пользовательского процесса для отладки про-
       граммы;
     • приостановка фоновых процессов операционной системой в
       случае выявления проблем.
